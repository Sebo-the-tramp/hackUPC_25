import os
import json5
from qwen_agent.agents import Assistant
from qwen_agent.tools.base import BaseTool, register_tool
from qwen_agent.utils.output_beautify import typewriter_print
from datetime import datetime

from backend.skyscanner_api import create_flight_search, get_flight_from_airport, find_top_k_full_paths

# Add chat history storage
chat_history = []

# defining the 4 people
users = [
  {
    "name": "Karolina",
    "location": "US",
    "passport": ["US", "Poland"],
    "budget": 2000.0,
    "availability": "July 2 - July 18",
    "visited": ["Germany", "Canada"],
    "preferences": {
      "climate": "mild",
      "activities": ["beach", "city tours"]
    },
    "age": 31,
    "language_spoken": ["English", "Polish"],
    "dietary_restrictions": "Vegetarian",
    "nearest_airport": ["JFK"]
  },
  {
    "name": "Mikka",
    "location": "Finland",
    "passport": ["Finland"],
    "budget": 1500.0,
    "availability": "June 15 - July 15",
    "visited": ["Sweden", "Norway"],
    "preferences": {
      "climate": "cool",
      "activities": ["nature", "cycling", "surfing"]
    },
    "age": 26,
    "language_spoken": ["Finnish", "English", "Swedish"],
    "dietary_restrictions": "Lactose intolerant",
    "nearest_airport": ["HEL"]
  },
  {
    "name": "Sebastian",
    "location": "Trento, Italy",
    "nearest_airport": ["VIE"],
    "passport": ["Italy"],
    "budget": 1800.0,
    "availability": "1st of July - 31st of July",
    "visited": ["Spain", "Ireland", "UAE", "Malta", "Bulgaria"],
    "preferences": {
      "activities": ["surfing", "bars"]
    },
    "age": 25,
    "language_spoken": ["Italian", "English", "German"],
    "dietary_restrictions": "Vegetarian"
  }
]
    
@register_tool('create_trip')
class QueryCost(BaseTool):
    description = 'Query the cost of a flight from the Skyscanner API using IATA codes.'
    parameters = [{
        'name': 'arrival_iata',
        'type': 'string',
        'description': 'Arrival airport IATA code (e.g., JFK, LHR, CDG). Must be a valid IATA code from the list of legal codes.',
        'required': True,
        # 'enum': ['AUH', 'JFK', 'LHR', 'CDG', 'DUB', 'HEL', 'BRG', 'LAX', 'SFO', 'ORD', 'DFW', 'ATL', 'PEK', 'HND', 'DXB', 'FRA', 'AMS', 'IST', 'MAD', 'BCN', 'MUC', 'ZRH', 'CPH', 'ARN', 'OSL', 'VIE', 'BRU', 'DUB', 'MAN', 'EDI', 'GLA', 'BRS', 'BHX', 'LPL', 'NCL', 'ABZ', 'INV', 'SOU', 'BOH', 'EXT', 'CWL', 'BFS', 'BHD', 'DSA', 'EMA', 'LBA', 'NQY', 'PLH', 'MME', 'HUY', 'NWI', 'STN', 'LTN', 'SEN', 'LCY', 'LGW', 'LHR', 'LBA', 'MAN', 'BHX', 'GLA', 'EDI', 'BRS', 'NCL', 'LPL', 'ABZ', 'INV', 'SOU', 'BOH', 'EXT', 'CWL', 'BFS', 'BHD', 'DSA', 'EMA', 'LBA', 'NQY', 'PLH', 'MME', 'HUY', 'NWI', 'STN', 'LTN', 'SEN', 'LCY', 'LGW', 'LHR', 'LSB']
    }, {
        'name': 'outbound_date',
        'type': 'string',
        'description': 'Outbound date in YYYY-MM-DD format.',
        'required': False
    }, {
        'name': 'inbound_date',
        'type': 'string',
        'description': 'Inbound date in YYYY-MM-DD format.',
        'required': False
    }, {
        'name': 'user_index_list',
        'type': 'array',
        'description': 'list of index of the user(s) involved in the trip',
        'required': False
    }]

    def call(self, params: str, **kwargs) -> str:
        # `params` are the arguments generated by the LLM agent.
        params = json5.loads(params)
        arrival_iata = params['arrival_iata']
        outbound_date = params['outbound_date']
        inbound_date = params.get('inbound_date', None)
        
        print(params)
        # Here you would implement the actual API call to Skyscanner.
        # For demonstration purposes, we will just return a mock response.

        # call the skyscanner api
        selected_users = [users[int(x)] for x in params['user_index_list']]

        options_user = []
        for user in selected_users:
            departure_iata = user['nearest_airport'][0] # Using the first airport's IATA code
            options = create_flight_search(departure_iata, arrival_iata, outbound_date, inbound_date)
            options_user.append({"name": user['name'], "options": options})
            # print(options)
        
        return json5.dumps({
            "departure_iata": departure_iata,
            "arrival_iata": arrival_iata,
            "outbound_date": outbound_date,
            "inbound_date": inbound_date,
            "options": options_user,
        }, ensure_ascii=False)

@register_tool('find_shared_flight')
class FindSharedFlight(BaseTool):
    description = 'Find the cheapest flight for the users.'
    parameters = [{
        'name': 'user_index_list',
        'type': 'array',
        'description': 'List of user indices to find shared flights for',
        'required': True
    }, {
        'name': 'start_date',
        'type': 'string',
        'description': 'Start date in YYYY-MM-DD format',
        'required': True
    }, {
        'name': 'end_date',
        'type': 'string',
        'description': 'End date in YYYY-MM-DD format',
        'required': True
    }]

    def call(self, params: str, **kwargs) -> str:
        params = json5.loads(params)
        user_index_list = params['user_index_list']
        start_date = params['start_date']
        end_date = params['end_date']
        
        # Get selected users
        selected_users = [users[int(x)] for x in user_index_list]
        
        # Prepare user data for flight search
        user_flight_data = []
        for user in selected_users:
            user_flight_data.append({
                "departure_iata": user['nearest_airport'][0],
                "start_date": start_date,
                "end_date": end_date
            })
        
        # Find shared flights using the existing function
        raw_user_list = []
        for user_data in user_flight_data:
            res_user, places_user = get_flight_from_airport(
                user_data["departure_iata"],
                user_data["start_date"],
                user_data["end_date"],
                1
            )
        raw_user_list.append(res_user)
        
        # Get top 5 shared flight options
        best_options = find_top_k_full_paths(raw_user_list, 10)
        
        # Format the response
        formatted_options = []
        for _, trips, total_cost in best_options:
            option = {
                "total_cost": total_cost,
                "flights": []
            }
            for trip in trips:
                flight = {
                    "from": places_user[trip["origin_place_id"]]["name"],
                    "to": places_user[trip["destination_place_id"]]["name"],
                    "price": trip["price"],
                }
                option["flights"].append(flight)
            formatted_options.append(option)
        
        return json5.dumps({
            "options": formatted_options
        }, ensure_ascii=False)
   
model_server = os.environ.get('LLM_URL', "enter LLM_URL")
print("model_server: ", model_server)
    
# Step 2: Configure the LLM you are using.
llm_cfg = {
    # Use the model service provided by DashScope:
    'model': 'qwen3:32b',
    'model_server': model_server,
    'generate_cfg': {
        'temperature': 0,
        'top_k': 1
    }
}

def get_ai_message(users, messages, socketio=None, trip_id=None):
    users_json = json5.dumps(users, ensure_ascii=False, indent=0)
    print("Getting AI message with users: ", users_json)
    system_instruction = f'''
    You are a travel planner assistant helping the user and their friends organize trips based on the user information provided in the system message.
    When the user requests travel advice or suggestions:
    - First you need to use the function find_shared_flight to find the cheapest flight for the users.
    - Then you need to rule out the flights that might not be liked by the users. Alway leave up to 5 options.
    - Then you need to propose the flights to the users using the create_trip function for each user.
    - Get the users preferences and evaluate if the proposed flights are suitable.
    - If the user likes the flight, you need to call the function create_trip to get the price of the flight.
    Current date is {datetime.now().strftime('%Y-%m-%d')}.

    User details:
    ''' + users_json

    bot = Assistant(llm=llm_cfg,
                    system_message=system_instruction,
                    function_list=['create_trip', 'find_shared_flight'],
                    files=[])

    response_plain_text = ""
    
    # Generate a unique message ID for streaming
    from uuid import uuid4
    message_id = str(uuid4())
    
    # If we have socketio, emit a start event
    if socketio and trip_id:
        socketio.emit('message_stream', {
            'type': 'start',
            'message_id': message_id,
            'trip_id': trip_id
        }, room=f'trip_{trip_id}')
    
    # Collect all characters from the response
    for response in bot.run(messages=messages):
        # Get the new characters
        old_text = response_plain_text
        response_plain_text = typewriter_print(response, response_plain_text)
        new_text = response_plain_text[len(old_text):]
        
        # Emit streaming update if socketio is available
        if socketio and trip_id and new_text:
            socketio.emit('message_stream', {
                'type': 'update',
                'message_id': message_id,
                'content': new_text,
                'trip_id': trip_id
            }, room=f'trip_{trip_id}')
    
    # Emit completion event if socketio is available
    if socketio and trip_id:
        socketio.emit('message_stream', {
            'type': 'end',
            'message_id': message_id,
            'trip_id': trip_id,
            'created_at': datetime.now().isoformat()
        }, room=f'trip_{trip_id}')
    
    return response_plain_text

# from qwen_agent.gui import WebUI
# WebUI(bot).run()    
